<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Functional Programming Playground</title>

<style>
  body {
    font-family: "Fira Code", monospace;
    background: linear-gradient(135deg, #232526, #414345);
    color: #f5f5f5;
    text-align: center;
    padding: 40px 20px;
  }

  h1 {
    color: #00ffc3;
    margin-bottom: 10px;
  }

  button {
    margin: 6px;
    padding: 10px 14px;
    background: #00ffc3;
    color: #111;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-weight: bold;
  }

  pre {
    background: #000;
    color: #0f0;
    padding: 15px;
    border-radius: 8px;
    width: 85%;
    margin: 20px auto;
    text-align: left;
  }
</style>
</head>

<body>

<h1>ğŸ§  Functional Programming Playground</h1>
<p>Explore purity, immutability, and declarative style.</p>

<button id="testPurity">ğŸ§ª Test Purity</button>
<button id="testImmutability">ğŸ“¦ Test Immutability</button>
<button id="testDeclarative">ğŸ§© Test Declarative Style</button>

<pre id="output"></pre>

<script>
// ===============================
// TASK 1: Identify Purity
// ===============================

// âœ… Pure function
function add(a, b) {
  return a + b;
}

// âŒ Side-effect function
let count = 0;
function increment() {
  count++;
  console.log("Count:", count);
  return count;
}

// âŒ Non-deterministic function
function randomNumber() {
  return Math.random();
}

// ===============================
// BONUS: Simple Purity Checker
// ===============================
function checkPurity(fn, label) {
  let before = count;
  const r1 = fn(2, 3);
  const r2 = fn(2, 3);
  let after = count;

  if (r1 !== r2) {
    return `${label}: âš ï¸ Impure (non-deterministic output)`;
  }
  if (before !== after) {
    return `${label}: âš ï¸ Impure (side effects detected)`;
  }
  return `${label}: âœ… Pure`;
}

// ===============================
// TASK 2: Immutability
// ===============================
const arr = [1, 2, 3];

// âŒ Impure â€“ mutates original array
function addNumberImpure(num) {
  arr.push(num);
  return arr;
}

// âœ… Pure â€“ returns new array
function addNumberPure(num) {
  return [...arr, num];
}

// ===============================
// TASK 3: Declarative vs Imperative
// ===============================

// Imperative
function doubleNumbers(arr) {
  let res = [];
  for (let i = 0; i < arr.length; i++) {
    res.push(arr[i] * 2);
  }
  return res;
}

// Declarative
function doubleNumbersDeclarative(arr) {
  return arr.map(x => x * 2);
}

// ===============================
// UI Logic
// ===============================
const output = document.getElementById("output");

document.getElementById("testPurity").addEventListener("click", () => {
  count = 0;
  output.textContent =
`TASK 1: Purity Check

${checkPurity(add, "add")}
${checkPurity(increment, "increment")}
${checkPurity(randomNumber, "randomNumber")}

Note:
â€¢ Pure â†’ same input, same output, no side effects
â€¢ Impure â†’ side effects OR non-deterministic behavior
`;
});

document.getElementById("testImmutability").addEventListener("click", () => {
  count = 0;
  const original = [...arr];

  const impureResult = addNumberImpure(4);
  const pureResult = addNumberPure(5);

  output.textContent =
`TASK 2: Immutability

Original array: ${JSON.stringify(original)}

After impure function:
Result: ${JSON.stringify(impureResult)}
Original mutated? â†’ YES âŒ

After pure function:
Result: ${JSON.stringify(pureResult)}
Original mutated? â†’ NO âœ…
`;
});

document.getElementById("testDeclarative").addEventListener("click", () => {
  const nums = [1, 2, 3];

  output.textContent =
`TASK 3: Declarative Thinking

Input: ${JSON.stringify(nums)}

Imperative result:
${JSON.stringify(doubleNumbers(nums))}

Declarative result:
${JSON.stringify(doubleNumbersDeclarative(nums))}

Observation:
â€¢ Declarative code is shorter
â€¢ Easier to read
â€¢ Still pure and predictable
`;
});
</script>

</body>
</html>
